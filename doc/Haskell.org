#+TITLE: Haskell

* Philosophy
  1. pure function
  2. type for engineering


* Basics
 
** Rules
  
*** Cpaitalization in Haskell
    1. Functions, Parameters and Bindings must start with a 
/lowercase/ letter. 
In case of an operator name, it *must not* start with :.
    2. Types, constructors, type classes and kinds must start
with an /uppercase/ letter. If using an operator name, it
*must* start with :.


* Practice

** packages

*** wreq
   An easy-to-use HTTP client library.

   A web client library that is designed for ease of use.

    [[https://www.stackage.org/lts-8.8/hoogle?q=wreq][Hoogle-LTS-8.8-Search]]
    [[http://www.serpentine.com/wreq/tutorial.html#uploading-data-via-post][wreq-tutorial]]

** intero

** ghci


*** tips

**** multi-line input
 Prelude> :{ 
 Prelude| 1/2 + 
 Prelude| 1/3 
 Prelude| :} 
 0.8333333333333333
   **Warning* to start a multiline block :{ must be the only text entered in the first line.


* Snippets

** real word haskell
   
*** Maybe >>= shortup?

**** text
  let forever a = a >> forever a
  forever Nothing
 Nothing
  let trueForever a = a >> trueForever a >> trueForever a
  trueForever Nothing
 Nothing
   
    *YES, Nothing >>= _ = Nothing will cause left shortup*

**** explain
    this is the comment:
     As of September 2012, (>>) does short circuit with Nothing.

 To test it, try in ghci:

 let forever a = a >> forever a
 forever Nothing

 If every (>>) did match a Nothing on the left and return a "new" Nothing, this computation should never end.
 Instead, it's istantaneous, because of the implementation of (>>) for maybe:

 Nothing >> _ = Nothing

 which short-circuits the computation the first time a Nothing is encountered.
* Language Extended
  
** String

__ ghci> :set -XOverloadedStrings

If youâ€™re using wreq from a Haskell source file, put a pragma at the top of your file:

{-# LANGUAGE OverloadedStrings #-}
